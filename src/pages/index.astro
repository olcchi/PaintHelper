---
import Layout from "../layouts/Layout.astro";
---

<Layout title="照片取色器">
  <main class="container flex-col justify-between h-100v mx-auto">
    <div
      class="relative flex items-center bg-white h-14 drop-shadow-[5px_-15px_50px_rgba(0,0,0,0.25)]"
    >
      <input type="file" id="fileInput" accept="image/*" hidden />
      <p class="text-center fixed left-2 p-2 select-none">照片取色器</p>
      <label
        class="fixed right-2 p-2 rounded-full bg-blue-600 text-white text-sm w-18 h-6 font-bold text-center cursor-pointer flex justify-center items-center"
        for="fileInput"
        class="upload-btn">上传照片</label
      >
    </div>
    <div class="image-container w-full h-50vh! flex-col relative">
      <canvas class="w-full h-full" id="mainCanvas"></canvas>
      <div></div>
      <canvas
        class="absolute top-2 right-2 w-24 h-24 z-20 border-solid border-gray-200 duration-200 transition-all opacity-100"
        id="zoomCanvas"></canvas>
    </div>

    <div class="relative w-full color-info flex items-center relative h-12">
      <div class="color-box w-full h-full"></div>
      <span
        class="color-value fixed right-0 bg-black text-white text-sm font-thin italic h-12 w-32 flex items-center justify-center"
        >#FFFFFF</span
      >
    </div>

    <div
      class="touchpad bg-gray-1 h-30vh min-h-20vh flex items-center justify-center text-2xl text-gray-2 select-none"
    >
      触控区域
    </div>
  </main>
</Layout>

<!-- <script>
  let mainCanvas: HTMLCanvasElement, zoomCanvas: HTMLCanvasElement;
  let mainCtx: CanvasRenderingContext2D | null,
    zoomCtx: CanvasRenderingContext2D | null;
  let sourceImage: ImageBitmap | null = null;
  let pickerPos = { x: 0, y: 0 };
  let isDragging = false;
  const dpr = window.devicePixelRatio || 1;

  // 初始化Canvas
  function initCanvas() {
    mainCanvas = document.getElementById("mainCanvas") as HTMLCanvasElement;
    zoomCanvas = document.getElementById("zoomCanvas") as HTMLCanvasElement;

    // 主画布配置
    mainCtx = mainCanvas.getContext("2d", { willReadFrequently: true });
    mainCanvas.style.touchAction = "none";

    // 放大镜画布配置
    zoomCtx = zoomCanvas.getContext("2d");
    zoomCanvas.width = 50 * dpr;
    zoomCanvas.height = 50 * dpr;
    zoomCanvas.style.width = "100px";
    zoomCanvas.style.height = "100px";
    zoomCanvas.onclick = function () {
      if (zoomCanvas.style.opacity === "0.25") zoomCanvas.style.opacity = "1";
      else zoomCanvas.style.opacity = "0.25";
    };
  }

  // 图片加载处理
  document
    .getElementById("fileInput")
    ?.addEventListener("change", async (e) => {
      const file = (e.target as HTMLInputElement)?.files?.[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = async (event) => {
        const img = new Image();
        img.src = event.target?.result as string;

        await new Promise((resolve) => (img.onload = resolve));
        sourceImage = await createImageBitmap(img);

        const container = document.querySelector(".image-container")!;
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const aspectRatio = img.width / img.height;

        // 计算适应容器高度的尺寸
        const displayHeight = containerHeight;
        const displayWidth = displayHeight * aspectRatio;

        // 配置Canvas物理尺寸
        mainCanvas.width = containerWidth * 1 *dpr;
        mainCanvas.height = containerHeight * 1 * dpr;
        mainCanvas.style.width = `${containerWidth}px`;
        mainCanvas.style.height = `${containerHeight}px`;

        // 初始绘制
        redrawCanvas();

        // 初始化取色器位置
        pickerPos = {
          x: mainCanvas.width / 2,
          y: mainCanvas.height / 2,
        };
        updateColorPicker();
      };
      reader.readAsDataURL(file);
    });

  // 统一重绘方法
  function redrawCanvas() {
    if (!sourceImage || !mainCtx) return;

    // 清除画布
    mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

    // 计算图片的宽高比和 canvas 的宽高比
    const imageAspectRatio = sourceImage.width / sourceImage.height;
    const canvasAspectRatio = mainCanvas.width / mainCanvas.height;

    let displayWidth, displayHeight, xOffset, yOffset;

    if (imageAspectRatio > canvasAspectRatio) {
        // 图片相对更宽，以 canvas 的宽度为基准进行缩放
        displayWidth = mainCanvas.width;
        displayHeight = mainCanvas.width / imageAspectRatio;
    } else {
        // 图片相对更高，以 canvas 的高度为基准进行缩放
        displayHeight = mainCanvas.height;
        displayWidth = mainCanvas.height * imageAspectRatio;
    }

    // 计算图片在 canvas 中居中显示的偏移量
    xOffset = (mainCanvas.width - displayWidth) / 2;
    yOffset = (mainCanvas.height - displayHeight) / 2;

    // 绘制原始图片
    mainCtx.drawImage(
        sourceImage,
        0, 0,
        sourceImage.width, sourceImage.height,
        xOffset, yOffset,
        displayWidth, displayHeight
    );
}

  // 更新取色器
  function updateColorPicker() {
    if (!mainCtx || !sourceImage) return;

    // 计算图像在画布上的显示尺寸和偏移量
    const aspectRatio = sourceImage.width / sourceImage.height;
    const displayHeight = mainCanvas.height;
    const displayWidth = displayHeight * aspectRatio;
    const xOffset = (mainCanvas.width - displayWidth) / 2;

    // 取色
    // 计算取色点在原始图像上的坐标
    const sourceX = Math.floor(
      (pickerPos.x - xOffset) * (sourceImage.width / displayWidth)
    );
    const sourceY = Math.floor(
      pickerPos.y * (sourceImage.height / displayHeight)
    );

    const tempCanvas = new OffscreenCanvas(1, 1);
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx!.drawImage(sourceImage, sourceX, sourceY, 1, 1, 0, 0, 1, 1);
    const pixel = tempCtx!.getImageData(0, 0, 1, 1).data;
    const hex = `#${((1 << 24) + (pixel[0] << 16) + (pixel[1] << 8) + pixel[2]).toString(16).slice(1)}`;
    document.querySelector(".color-box")!.style.backgroundColor = hex;
    document.querySelector(".color-value")!.textContent = hex;

    // 计算反色
    const inverseR = 255 - pixel[0];
    const inverseG = 255 - pixel[1];
    const inverseB = 255 - pixel[2];
    const inverseHex = `#${((1 << 24) + (inverseR << 16) + (inverseG << 8) + inverseB).toString(16).slice(1)}`;

    // 更新放大镜
    if (zoomCtx) {
      const zoomSize = 8 * dpr;
      zoomCtx.clearRect(0, 0, zoomCanvas.width, zoomCanvas.height);

      const zoomSourceX = Math.floor(
        (pickerPos.x - xOffset - zoomSize / 2) *
          (sourceImage.width / displayWidth)
      );
      const zoomSourceY = Math.floor(
        (pickerPos.y - zoomSize / 2) * (sourceImage.height / displayHeight)
      );
      const zoomSourceWidth = Math.ceil(
        zoomSize * (sourceImage.width / displayWidth)
      );
      const zoomSourceHeight = Math.ceil(
        zoomSize * (sourceImage.height / displayHeight)
      );

      zoomCtx.drawImage(
        sourceImage,
        zoomSourceX,
        zoomSourceY,
        zoomSourceWidth,
        zoomSourceHeight,
        0,
        0,
        zoomCanvas.width,
        zoomCanvas.height
      );
    }

    // 绘制十字准星到主画布
    mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
    mainCtx.drawImage(
      sourceImage,
      0,
      0,
      sourceImage.width,
      sourceImage.height,
      xOffset,
      0,
      displayWidth,
      displayHeight
    );

    const crosshairSize = 10 * dpr;
    const lineWidth = 1 * dpr;
    mainCtx.strokeStyle = inverseHex; // 使用反色作为准心颜色
    mainCtx.lineWidth = lineWidth;

    // 绘制水平线段
    mainCtx.beginPath();
    mainCtx.moveTo(pickerPos.x - crosshairSize / 2, pickerPos.y);
    mainCtx.lineTo(pickerPos.x + crosshairSize / 2, pickerPos.y);
    mainCtx.stroke();

    // 绘制垂直线段
    mainCtx.beginPath();
    mainCtx.moveTo(pickerPos.x, pickerPos.y - crosshairSize / 2);
    mainCtx.lineTo(pickerPos.x, pickerPos.y + crosshairSize / 2);
    mainCtx.stroke();
  }

  // 触摸交互处理
  const touchpad = document.querySelector(".touchpad");
  let startX = 0,
    startY = 0;

  touchpad?.addEventListener("touchstart", (e: TouchEvent) => {
    e.preventDefault();
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
    isDragging = true;
  });

  touchpad?.addEventListener("touchmove", (e: TouchEvent) => {
    if (!isDragging || !sourceImage) return;
    e.preventDefault();

    const deltaX = e.touches[0].clientX - startX;
    const deltaY = e.touches[0].clientY - startY;

    pickerPos.x = Math.min(
      Math.max(pickerPos.x + deltaX * dpr * 2, 0),
      mainCanvas.width
    );
    pickerPos.y = Math.min(
      Math.max(pickerPos.y + deltaY * dpr * 2, 0),
      mainCanvas.height
    );

    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;

    // 优化性能的重绘
    requestAnimationFrame(() => {
      redrawCanvas();
      updateColorPicker();
    });
  });

  touchpad?.addEventListener("touchend", () => {
    isDragging = false;
  });

  window.addEventListener("load", initCanvas);
</script> -->

<script>
  let mainCanvas: HTMLCanvasElement, zoomCanvas: HTMLCanvasElement;
  let mainCtx: CanvasRenderingContext2D | null,
    zoomCtx: CanvasRenderingContext2D | null;
  let sourceImage: ImageBitmap | null = null;
  let pickerPos = { x: 0, y: 0 };
  let isDragging = false;
  const dpr = window.devicePixelRatio || 1;

  // 初始化Canvas
  function initCanvas() {
    mainCanvas = document.getElementById("mainCanvas");
    zoomCanvas = document.getElementById("zoomCanvas");

    // 主画布配置
    mainCtx = mainCanvas.getContext("2d", { willReadFrequently: true });
    mainCanvas.style.touchAction = "none";

    // 放大镜画布配置
    zoomCtx = zoomCanvas.getContext("2d");
    zoomCanvas.width = 50 * dpr;
    zoomCanvas.height = 50 * dpr;
    zoomCanvas.style.width = "100px";
    zoomCanvas.style.height = "100px";
    zoomCanvas.onclick = function () {
      if (zoomCanvas.style.opacity === "0.25") zoomCanvas.style.opacity = "1";
      else zoomCanvas.style.opacity = "0.25";
    };
  }

  // 图片加载处理
  document.getElementById("fileInput").addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (event) => {
      const img = new Image();
      img.src = event.target.result;

      await new Promise((resolve) => (img.onload = resolve));
      sourceImage = await createImageBitmap(img);

      const container = document.querySelector(".image-container");
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;

      // 配置Canvas物理尺寸
      mainCanvas.width = containerWidth * 0.7 * dpr;
      mainCanvas.height = containerHeight * 0.7 * dpr;
      mainCanvas.style.width = `${containerWidth}px`;
      mainCanvas.style.height = `${containerHeight}px`;

      // 初始绘制
      redrawCanvas();

      // 初始化取色器位置
      pickerPos = {
        x: mainCanvas.width / 2,
        y: mainCanvas.height / 2,
      };
      updateColorPicker();
    };
    reader.readAsDataURL(file);
  });

  // 统一重绘方法
  function redrawCanvas() {
    if (!sourceImage || !mainCtx) return;

    // 清除画布
    mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

    const imageAspectRatio = sourceImage.width / sourceImage.height;
    const canvasAspectRatio = mainCanvas.width / mainCanvas.height;

    let displayWidth, displayHeight, xOffset, yOffset;

    if (imageAspectRatio > canvasAspectRatio) {
      // 图片相对更宽，以 canvas 的宽度为基准进行缩放
      displayWidth = mainCanvas.width;
      displayHeight = displayWidth / imageAspectRatio;
    } else {
      // 图片相对更高，以 canvas 的高度为基准进行缩放
      displayHeight = mainCanvas.height;
      displayWidth = displayHeight * imageAspectRatio;
    }

    // 计算图片在 canvas 中居中显示的偏移量
    xOffset = (mainCanvas.width - displayWidth) / 2;
    yOffset = (mainCanvas.height - displayHeight) / 2;

    // 绘制原始图片
    mainCtx.drawImage(
      sourceImage,
      0,
      0,
      sourceImage.width,
      sourceImage.height,
      xOffset,
      yOffset,
      displayWidth,
      displayHeight
    );
  }

  // 更新取色器
  function updateColorPicker() {
    if (!mainCtx || !sourceImage) return;

    const imageAspectRatio = sourceImage.width / sourceImage.height;
    const canvasAspectRatio = mainCanvas.width / mainCanvas.height;

    let displayWidth, displayHeight, xOffset, yOffset;

    if (imageAspectRatio > canvasAspectRatio) {
      // 图片相对更宽，以 canvas 的宽度为基准进行缩放
      displayWidth = mainCanvas.width;
      displayHeight = displayWidth / imageAspectRatio;
    } else {
      // 图片相对更高，以 canvas 的高度为基准进行缩放
      displayHeight = mainCanvas.height;
      displayWidth = displayHeight * imageAspectRatio;
    }

    // 计算图片在 canvas 中居中显示的偏移量
    xOffset = (mainCanvas.width - displayWidth) / 2;
    yOffset = (mainCanvas.height - displayHeight) / 2;

    // 取色
    // 计算取色点在原始图像上的坐标
    const sourceX = Math.floor(
      (pickerPos.x - xOffset) * (sourceImage.width / displayWidth)
    );
    const sourceY = Math.floor(
      (pickerPos.y - yOffset) * (sourceImage.height / displayHeight)
    );

    const tempCanvas = new OffscreenCanvas(1, 1);
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.drawImage(sourceImage, sourceX, sourceY, 1, 1, 0, 0, 1, 1);
    const pixel = tempCtx.getImageData(0, 0, 1, 1).data;
    const hex = `#${((1 << 24) + (pixel[0] << 16) + (pixel[1] << 8) + pixel[2]).toString(16).slice(1)}`;
    document.querySelector(".color-box").style.backgroundColor = hex;
    document.querySelector(".color-value").textContent = hex;

    // 计算反色
    const inverseR = 255 - pixel[0];
    const inverseG = 255 - pixel[1];
    const inverseB = 255 - pixel[2];
    const inverseHex = `#${((1 << 24) + (inverseR << 16) + (inverseG << 8) + inverseB).toString(16).slice(1)}`;

    // 更新放大镜
    if (zoomCtx) {
      const zoomSize = 8 * dpr;
      zoomCtx.clearRect(0, 0, zoomCanvas.width, zoomCanvas.height);

      const zoomSourceX = Math.floor(
        (pickerPos.x - xOffset - zoomSize / 2) *
          (sourceImage.width / displayWidth)
      );
      const zoomSourceY = Math.floor(
        (pickerPos.y - yOffset - zoomSize / 2) *
          (sourceImage.height / displayHeight)
      );
      const zoomSourceWidth = Math.ceil(
        zoomSize * (sourceImage.width / displayWidth)
      );
      const zoomSourceHeight = Math.ceil(
        zoomSize * (sourceImage.height / displayHeight)
      );

      zoomCtx.drawImage(
        sourceImage,
        zoomSourceX,
        zoomSourceY,
        zoomSourceWidth,
        zoomSourceHeight,
        0,
        0,
        zoomCanvas.width,
        zoomCanvas.height
      );
    }

    // 绘制十字准星到主画布
    redrawCanvas();

    const crosshairSize = 10 * dpr;
    const lineWidth = 1 * dpr;
    mainCtx.strokeStyle = inverseHex; // 使用反色作为准心颜色
    mainCtx.lineWidth = lineWidth;

    // 绘制水平线段
    mainCtx.beginPath();
    mainCtx.moveTo(pickerPos.x - crosshairSize / 2, pickerPos.y);
    mainCtx.lineTo(pickerPos.x + crosshairSize / 2, pickerPos.y);
    mainCtx.stroke();

    // 绘制垂直线段
    mainCtx.beginPath();
    mainCtx.moveTo(pickerPos.x, pickerPos.y - crosshairSize / 2);
    mainCtx.lineTo(pickerPos.x, pickerPos.y + crosshairSize / 2);
    mainCtx.stroke();
  }

  // 触摸交互处理
  const touchpad = document.querySelector(".touchpad");
  let startX = 0;
  let startY = 0;

  touchpad.addEventListener("touchstart", (e) => {
    e.preventDefault();
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
    isDragging = true;
  });

  touchpad.addEventListener("touchmove", (e) => {
    if (!isDragging || !sourceImage) return;
    e.preventDefault();

    const deltaX = e.touches[0].clientX - startX;
    const deltaY = e.touches[0].clientY - startY;

    pickerPos.x = Math.min(
      Math.max(pickerPos.x + deltaX * dpr * 2, 0),
      mainCanvas.width
    );
    pickerPos.y = Math.min(
      Math.max(pickerPos.y + deltaY * dpr * 2, 0),
      mainCanvas.height
    );

    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;

    // 优化性能的重绘
    requestAnimationFrame(() => {
      redrawCanvas();
      updateColorPicker();
    });
  });

  touchpad!.addEventListener("touchend", () => {
    isDragging = false;
  });

  window.addEventListener("load", initCanvas);
</script>
<style></style>
